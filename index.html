<!DOCTYPE html>
<meta charset="utf-8">
<style>
    /* --Exchange lines-- */
    .dashed-line {
        stroke-width: 3;
        stroke: #B10000;
        stroke-linejoin: round;
        stroke-dasharray: 4;
        stroke-opacity: 1;
        animation: dash 1s linear infinite;
    }

    @keyframes dash {
        to {
            stroke-dashoffset: 0;
        }
    }

    /* --Countries-- */
    .subunit.DNK {
        fill: #34847d;
        position: absolute;
    }
    .subunit.DNB {
        fill: #34847d;
        position: absolute;
    }
    .subunit.SWE {
        fill: #e9eeee;
        position: absolute;
    }
    .subunit.DEU {
        fill: #e9eeee;
        position: absolute;
    }

    /* --Cities/Features-- */
    .place-label {
        fill: #000;
        fill-opacity: 1;
        font-size: 20px;
        font-weight: 300;
        text-anchor: middle;
        position: absolute;
    }
    text {
        -webkit-user-select:none;
        -khtml-user-select:none;
        -moz-user-select:none;
        -ms-user-select:none;
        -o-user-select:none;
        user-select:none;
        position: absolute;
    }

    /* --Textbox-- */
    .textbox.rect {
        fill: #e9eeee;
        opacity: 0.7;
        stroke: white;
        stroke-width: 2.5px ;
    }
    .textbox.text {
        font-weight: bolder;
    }

    .textbox {
        fill: #34847d;
        font-family: "Trebuchet MS";
        font-size: 12px;
    }

    /* --Windmill-- */
    .windmill_rotor {
        transform-origin: 50% 50%;
        transition: 60s;
        -webkit-animation: rotate 3s linear infinite;
        animation: rotate 3s linear infinite;
    }
    @-webkit-keyframes rotate {
        100% {
            -webkit-transform: rotate(360deg);
        }
    }
    @keyframes rotate {
        100% {
            transform: rotate(360deg);
        }
    }
    .windmill_pole {
        width: 4px;
        fill: white;
        stroke: black;
        stroke-width: 2px;
        height: 40px;
    }


</style>


<body>
    <script src="http://mbostock.github.com/d3/d3.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

    <script src="//d3js.org/d3.v3.min.js" charset="utf-8"></script>

    <script src="//d3js.org/topojson.v1.min.js"></script>

    <script src="gauge.js"></script>

    <script>

        var dataFetchInterval_ms = 2000;
        /*  --------- CREATION OF SVG  --------- */
        // SVG Height and Width
        var width = 1100,
            height = 600;

        // d3 is used to create SVG
        var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height);

        // Choose projection and rotate/scale world
        var projection = d3.geo.albers()
            .center([24.8, 52.95])
            .rotate([0, 0, -10])
            .parallels([50, 60])
            .scale(10200)
            .translate([width / 2, height / 2]);

        /*  --------- COORDINATES FOR THE SVG --------- */
        var coords = {
            thorup_strand:[9.092772,57.1380563],
            kristiansand:[7.8691287,58.1529008],
            asaa:[10.417415,57.147015],
            goeteborg:[11.6136556,57.7006826],
            odense:[10.379272,55.399767],
            jyderup:[11.410810, 55.657214],
            rens:[9.150874, 54.874238],
            rendsburg:[9.5900401,54.2969277],
            helsingoer: [12.593724,56.035637],
            helsingborg:[12.719173,56.061975],
            ringsted:[11.789062, 55.456724],
            rostock: [12.0068693,54.1474698],
            hasle: [14.6718209,55.2079184],
            borrby: [14.1621923,55.456073],
            anholt_windmill_park: [11.174104, 56.597480],
            nysted_windmill_park: [11.698845, 54.575794],
            horns_rev_windmill_park : [7.859741, 55.560579],
            silkeborg_solar_farm: [9.537419, 56.206914],
            gaugePlacement: [13.756697,57.270417]
        };

        /* --------- CREATE PATH ---------*/
        var path = d3.geo.path()
            .projection(projection);

        // Layering of elements due to d3 not supporting z-index layering
        var map = svg.append('svg');
        var dashedLineGroup = svg.append('g').attr('id','dashedLine');
        var solarGroup = svg.append('g').attr('id','solar');
        var windmillGroup = svg.append('g').attr('id','windmills');
        var textboxRectGroup = svg.append('g').attr("id","textboxRect");
        var textboxTextGroup = svg.append('g').attr("id","textboxText");
        var gaugeGroup = svg.append('g').attr("id","gauges");


         /* ----- CREATE ENERGY LINES ----- */

        function energyLine(coord,coord_offset_x,coord_offset_y,width,height,dashed_line_coords,id,text,value){
            this.upper_right_coordinates = [coord[0]+coord_offset_x, coord[1]+coord_offset_y ];
            this.x = projection(this.upper_right_coordinates)[0];
            this.y = projection(this.upper_right_coordinates)[1];
            this.id = id;
            this.text = text;
            this.dashed_line_coords = dashed_line_coords;

            // SET UP DASHED LINE
            dashedLineGroup.append("path")
                .datum({
                    type: "LineString", coordinates: this.dashed_line_coords.coord // points in decimal degrees
                })
                .attr("d", path)
                .attr("class", "dashed-line " + this.id)
                .attr("stroke-dashoffset", dashOffset );

            // SET UP TEXT ELEMENT WITH CHOSEN SIZE (CSS)
            this.textElement = textboxTextGroup.append("text")
                .text(this.text)
                .attr("class", "textbox text "+this.id)
                .attr("id",this.id);

            // PLACE TEXT ELEMENT BASED ON LENFTH AND SIZE
            this.x -= this.textElement.node().getBBox().width;
            this.textElement
                .attr('y', this.y)
                .attr('x', this.x);


            // SET UP VALUE TEXT FILED
            this.distanceBetweenTexts = 0.2 * this.textElement.node().getBBox().height;
            this.valueElement = textboxTextGroup.append("text")
                .text(this.text)
                .attr('x', this.x)
                .attr('y', this.y + this.distanceBetweenTexts + this.textElement.node().getBBox().height)
                .attr("class", "textbox value "+this.id)
                .attr("id",this.id + " Value");

            // SET UP RECTANGLE BOX BEHIND TEXT
            this.rect_offset = this.textElement.node().getBBox().height;
            this.offset_factor = 2;

            this.rectElement = textboxRectGroup.append("rect")
                .attr('width', this.textElement.node().getBBox().width + this.offset_factor * this.rect_offset)
                .attr('height', this.textElement.node().getBBox().height  + this.valueElement.node().getBBox().height + this.distanceBetweenTexts + this.rect_offset )

            this.rectElement
                .attr('x', this.x - this.rect_offset )
                .attr('y', this.y - this.textElement.node().getBBox().height + this.distanceBetweenTexts - this.rect_offset/2 )
                .attr("class", "textbox rect "+this.id)
                .attr("id",this.id);

            // FUNCTION TO UPDATE VALUE IN TEXTBOX AND CHANGE DIRECTION OF DASHED LINE BASED ON VALUE
            this.updateValue = function(value)
            {
                if(value < 0){
                    value = "IMPORT: " +value.slice(0) + " MW";
                    dashedLineGroup.select(".dashed-line."+this.id)
                        .attr("stroke-dashoffset", -dashOffset );
                }
                else{
                    value = "EXPORT: " +value + " MW";
                    dashedLineGroup.select(".dashed-line."+this.id)
                        .attr("stroke-dashoffset", dashOffset );
                }

                this.valueElement
                    .text(value)
                    .attr("x",this.x + this.textElement.node().getComputedTextLength() / 2 -this.valueElement.node().getComputedTextLength() / 2 );
            }

            // FORCE CONSTRUCTION OF ELEMENT TO UPDATE VALUE
            this.updateValue(value);
        };

        // Start-End coordinates of dashed lines (LONG,LATI) corresponding to (E,N)
        function dashed_line(start_coord,stop_coord,id){
            this.coord = [start_coord, stop_coord];
        };
        // Creation of object with all dashed line coords
        var dashed_lines = [
            new dashed_line(coords.thorup_strand,coords.kristiansand),
            new dashed_line(coords.asaa,coords.goeteborg),
            new dashed_line(coords.rens,coords.rendsburg),
            new dashed_line(coords.helsingoer,coords.helsingborg),
            new dashed_line(coords.ringsted,coords.rostock),
            new dashed_line(coords.odense,coords.jyderup),
            new dashed_line(coords.hasle,coords.borrby)
        ];
        // Dashed line offset controls animation
        var dashOffset = 48;

        // Creation of energy lines. Dashed-lines and Textboxes will be created
        var energyLines = [
            new energyLine(coords.thorup_strand,-0.15,0.1,140,65,dashed_lines[0],"jylland-norge","JYLLAND - NORGE",10),
            new energyLine(coords.asaa,1.7,0.05,150,50,dashed_lines[1],"jylland-sverige","JYLLAND - SVERIGE",10),
            new energyLine(coords.rens,-0.15,0.1,150,50,dashed_lines[2],"jylland-tyskland","JYLLAND - TYSKLAND",10),
            new energyLine(coords.helsingoer,1.7,0.2,150,50,dashed_lines[3],"sjaelland-sverige","SJÆLLAND - SVERIGE",10),
            new energyLine(coords.ringsted,1.7,-0.5,150,50,dashed_lines[4],"sjaelland-tyskland","SJÆLLAND - TYSKLAND",10),
            new energyLine(coords.odense,0.8,-0.1,150,50,dashed_lines[5],"storebaelt","STOREBÆLT",10),
            new energyLine(coords.hasle,-0.15,0.1,150,50,dashed_lines[6],"bornholm-sverige","BORNHOLM - SVERIGE",10),
        ];

        // Update Energy lines values
        // Function to update gauge vaule
        function arrayHasOwnIndex(array, prop) {
            return array.hasOwnProperty(prop) && /^0$|^[1-9]\d*$/.test(prop) && prop <= 4294967294; // 2^32 - 2
        }
        function updateEnergyLines() {
            energyLines.forEach( function (arrayItem)
            {
                // INSERT FETCH OF ENERGY DATA HERE
                var overflow = 0; //10;
                var value = 0 - overflow + (200 - 0 + overflow * 2) * Math.random() - 100;
                arrayItem.updateValue(String(Math.round(value)));
            });
        }
        // Make gauge value be updated every 5000 ms
        setInterval(updateEnergyLines, dataFetchInterval_ms);

        /* ----- ANIMATED WINDMILLS ----- */
        function windmill(svgGroup, coord, rotorWidth, rotorHeight, poleWidth, poleHeight, offsetWidth, offsetHeight, id){
            projectedCoords = projection(coord);
            svgGroup.append("rect")
                .attr("x",projectedCoords[0]-Math.round(poleWidth/2)-offsetWidth)
                .attr("y",projectedCoords[1]-poleHeight-offsetHeight)
                .attr("id",id)
                .attr("class","windmill_pole");

            svgGroup.append("image")
                .attr("height",rotorHeight)
                .attr("x",projectedCoords[0]-Math.round(rotorWidth/2)-offsetWidth)
                .attr("y",projectedCoords[1]-2*poleHeight-offsetHeight)
                .attr("xlink:href","img/windmill_rotor.png")
                .attr("id",id)
                .attr("class","windmill_rotor");
        }

        function windmillPark(svgGroup, coord, rotorWidth, rotorHeight, poleWidth, poleHeight, id) {
            windmillParkWidthOffset = 20;
            windmillParkHeightOffset = 20;
            windmill(svgGroup, coord,rotorWidth,rotorHeight,poleWidth,poleHeight,windmillParkWidthOffset,windmillParkHeightOffset,id);
            windmill(svgGroup, coord,rotorWidth,rotorHeight,poleWidth,poleHeight,0,0,id);
        }

        windmillPark(windmillGroup, coords.anholt_windmill_park,75,75,6,40,0,0,'windmill');
        windmill(windmillGroup, coords.nysted_windmill_park,75,75,6,40,0,0,'windmill');
        windmillPark(windmillGroup, coords.horns_rev_windmill_park,75,75,6,40,0,0,'windmill');

        /* ----- SOLAR PANELS ----- */
        function solarPanel(svgGroup, coord, width, height, id){
            projectedCoords = projection(coord);

            svgGroup.append("image")
                .attr("height",height)
                .attr("x",projectedCoords[0]-Math.round(width/2))
                .attr("y",projectedCoords[1]-Math.round(height/2))
                .attr("xlink:href","img/solar_panel.png")
                .attr("id",id)
        }

        solarPanel(solarGroup, coords.silkeborg_solar_farm,60,60,'solar');

        /* -------- CREATE GAUGE -------- */
        // Create Gauge
        var gauge = createGauge( "CO2",gaugeGroup,120,"CO2",100,200,5);

        // Placment of gauge on the map
        var gaugePlacement = ' translate(' + projection(coords.gaugePlacement) + ')';
        gaugeGroup
            .attr('transform', gaugePlacement);

        // Function to update gauge vaule
        function updateGauge()
        {
            // INSERT FETCH OF CO2 DATA HERE
            var value = gauge.getRandomValue();
            gauge.redraw(value);
        }

        // Make gauge value be updated every 1000 ms
        setInterval(updateGauge, dataFetchInterval_ms);

        /* --------- CREATE MAP --------- */
        // Get JSON file and create the world on layer1 (Background)
        d3.json("dk_ger_swe.json", function(error, topo) {

            // VARIABLES
            var subunits = topojson.feature(topo, topo.objects.subunits);
            var subunits_features = topojson.feature(topo, topo.objects.subunits).features;
            var places = topojson.feature(topo, topo.objects.places);
            var places_features = topojson.feature(topo, topo.objects.places).features;


            // GET ALL SUBUNITS FROM SHAPEFILE AND APPEND TO PATH
            map.selectAll(".subunit")
                .data(subunits_features)
                .enter().append("path")
                .attr("class", function(d) { return "subunit " + d.id; })
                .attr("d", path);

            // GET PLACES (CITIES) FROM PLACES SHAPEFILE
            map.append("path")
                .datum(places)
                .attr("d", path)
                .attr("class", "place");
        });

    </script>
</body>